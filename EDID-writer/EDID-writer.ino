/*
 * EDID writer for CAT24C208 EEPROM
 */
#include <Wire.h>

#define EEPROM_I2C_ADDR 0x50
#define EEPROM_I2C_SEGMENT_POINTER_ADDR 0x30

#if 1
// 24C02N ATMEL
#define EEPROM_SIZE 256  // 2048bits
#define EEPROM_WRITE_DELAY 5
#else
// CAT24C208 ON Semiconductor
#define EEPROM_SIZE 512  // 4096bits
#define EEPROM_I2C_CONFIG_ADDR 0x31
#define EEPROM_I2C_CONFIG_BYTE 0x0c // write enable, lower bank
#define EEPROM_WRITE_DELAY 10
#endif

#define WIRE_SUCCESS 0
#define WIRE_ERROR_BUFFER_OVERFLOW 1
#define WIRE_ERROR_ADDRESS_NACK 2
#define WIRE_ERROR_DATA_NACK 3
#define WIRE_ERROR_OTHER 4

#if 0
/*
 * EDID (dummy)
 */
byte eepromdat[] = {
    // block 0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // block 1
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // block 2
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // block 3
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif

#if 0
/*
 * EDID (FUERAN 3840x2160@60Hz https://www.amazon.co.jp/gp/product/B0711LLSFM)
 */
byte eepromdat[] = {
    // block 0
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x05, 0xE3, 0x16, 0x10, 0xE0, 0x00, 0x00, 0x00,
    0x26, 0x19, 0x01, 0x03, 0x80, 0x35, 0x1E, 0x78, 0x2A, 0xA0, 0xA5, 0xA6, 0x56, 0x52, 0x9D, 0x27,
    0x0F, 0x50, 0x54, 0xBF, 0xCE, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0x0F, 0x28, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x32, 0x4C, 0x1E,
    0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x31,
    0x30, 0x31, 0x36, 0x57, 0x31, 0x4D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFF,
    0x00, 0x42, 0x55, 0x57, 0x45, 0x33, 0x39, 0x41, 0x30, 0x30, 0x30, 0x32, 0x32, 0x34, 0x01, 0x5D,

    // block 1
    0x02, 0x03, 0x12, 0xF1, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00,
    0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x0F, 0x28,
    0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00,
    0x0F, 0x28, 0x21, 0x00, 0x00, 0x1E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E,
    0x96, 0x00, 0x0F, 0x28, 0x21, 0x00, 0x00, 0x18, 0x8C, 0x0A, 0xD0, 0x90, 0x20, 0x40, 0x31, 0x20,
    0x0C, 0x40, 0x55, 0x00, 0x0F, 0x28, 0x21, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC,
};
#endif

#if 1
/*
 * EDID (LG Monitor Display 32UK550-B 31.5"/4K/HDR10 https://www.amazon.co.jp/-/en/gp/product/B07HRZ7LFB)
 */
byte eepromdat[] = {
    // block 0
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x1E, 0x6D, 0x06, 0x77, 0xDE, 0x1D, 0x00, 0x00, 
    0x04, 0x1D, 0x01, 0x03, 0x80, 0x3C, 0x22, 0x78, 0xEA, 0x3E, 0x31, 0xAE, 0x50, 0x47, 0xAC, 0x27, 
    0x0C, 0x50, 0x54, 0x21, 0x08, 0x00, 0x71, 0x40, 0x81, 0x80, 0x81, 0xC0, 0xA9, 0xC0, 0xD1, 0xC0, 
    0x81, 0x00, 0x01, 0x01, 0x01, 0x01, 0x08, 0xE8, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58, 
    0x8A, 0x00, 0x58, 0x54, 0x21, 0x00, 0x00, 0x1E, 0x04, 0x74, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 
    0xB0, 0x58, 0x8A, 0x00, 0x58, 0x54, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x38, 
    0x3D, 0x1E, 0x87, 0x3C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 
    0x00, 0x4C, 0x47, 0x20, 0x48, 0x44, 0x52, 0x20, 0x34, 0x4B, 0x0A, 0x20, 0x20, 0x20, 0x01, 0xE2, 
    // block 1
    0x02, 0x03, 0x38, 0x71, 0x4D, 0x90, 0x22, 0x20, 0x1F, 0x12, 0x03, 0x04, 0x01, 0x61, 0x60, 0x5D, 
    0x5E, 0x5F, 0x23, 0x09, 0x07, 0x07, 0x6D, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x3C, 0x20, 0x00, 
    0x60, 0x01, 0x02, 0x03, 0x67, 0xD8, 0x5D, 0xC4, 0x01, 0x78, 0x80, 0x03, 0xE3, 0x0F, 0x00, 0x03, 
    0xE3, 0x05, 0xC0, 0x00, 0xE3, 0x06, 0x05, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
    0x58, 0x2C, 0x45, 0x00, 0x58, 0x54, 0x21, 0x00, 0x00, 0x1E, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 
    0x29, 0x50, 0x30, 0x20, 0x35, 0x00, 0x58, 0x54, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 
    0x00, 0x39, 0x30, 0x34, 0x4E, 0x54, 0x55, 0x57, 0x30, 0x37, 0x36, 0x34, 0x36, 0x0A, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 
};
#endif

void i2c_print_error(char* op, int address, int status)
{
    Serial.print("I2C ERROR: ");
    Serial.print(op);
    Serial.print(" address=0x");
    Serial.print(address, HEX);
    Serial.print(" status=");
    Serial.print(status);
    Serial.println();
}

int i2c_eeprom_read_segment_byte(uint16_t eeaddress, byte* rdata, bool segment)
{
    int status;
    int max_retry = 50;

    *rdata = 0xFF;

  retry:
    if (segment) {
        Wire.beginTransmission(EEPROM_I2C_SEGMENT_POINTER_ADDR);
        Wire.write((byte)(eeaddress / 0x100));
        status = Wire.endTransmission(false);  // no STOP condition
        if (status != WIRE_SUCCESS) {
            if (status == WIRE_ERROR_ADDRESS_NACK || status == WIRE_ERROR_DATA_NACK) {
                delay(5);
                if (0 < max_retry--)
                    goto retry;
            }
            i2c_print_error("write", EEPROM_I2C_SEGMENT_POINTER_ADDR, status);
            return status;
        }
    }

    Wire.beginTransmission(EEPROM_I2C_ADDR);
    Wire.write((byte)(eeaddress % 0x100));
    status = Wire.endTransmission(false);  // no STOP condition
    if (status != WIRE_SUCCESS) {
        if (status == WIRE_ERROR_ADDRESS_NACK || status == WIRE_ERROR_DATA_NACK) {
            delay(1);
            if (0 < max_retry--)
                goto retry;
        }
        i2c_print_error("write", EEPROM_I2C_ADDR, status);
        return status;
    }

    Wire.requestFrom(EEPROM_I2C_ADDR, (uint8_t)1);
    while (!Wire.available()); 
    *rdata = Wire.read();

    return WIRE_SUCCESS;
}

int i2c_eeprom_write_segment_byte(uint16_t eeaddress, byte data, bool segment)
{
    int status;
    int max_retry = 50;

  retry:
    if (segment) {
        Wire.beginTransmission(EEPROM_I2C_SEGMENT_POINTER_ADDR);
        Wire.write((byte)(eeaddress / 0x100));
        status = Wire.endTransmission(false);  // no STOP condition
        if (status != WIRE_SUCCESS) {
            if (status == WIRE_ERROR_ADDRESS_NACK || status == WIRE_ERROR_DATA_NACK) {
                delay(5);
                if (0 < max_retry--)
                    goto retry;
            }
            i2c_print_error("write", EEPROM_I2C_SEGMENT_POINTER_ADDR, status);
            return status;
        }
    }

    Wire.beginTransmission(EEPROM_I2C_ADDR);
    Wire.write((byte)(eeaddress % 0x100));
    Wire.write(data);
    status = Wire.endTransmission();
    if (status != WIRE_SUCCESS) {
        if (status == WIRE_ERROR_ADDRESS_NACK || status == WIRE_ERROR_DATA_NACK) {
            delay(1);
            if (0 < max_retry--)
                goto retry;
        }
        i2c_print_error("write", EEPROM_I2C_ADDR, status);
        return status;
    }

    return WIRE_SUCCESS;
}

int i2c_write_byte(uint8_t deviceaddress, int eeaddress, byte data)
{
    int status;
    int max_retry = 50;

  retry:
    Wire.beginTransmission(deviceaddress);
    Wire.write((byte)eeaddress);
    Wire.write(data);
    status = Wire.endTransmission();
    if (status != WIRE_SUCCESS) {
        if (status == WIRE_ERROR_ADDRESS_NACK || status == WIRE_ERROR_DATA_NACK) {
            delay(1);
            if (0 < max_retry--)
                goto retry;
        }
        i2c_print_error("write", EEPROM_I2C_ADDR, status);
        return status;
    }

    return WIRE_SUCCESS;
}

void write_read_verify(bool do_write, bool do_read, bool do_verify, bool cformat = false)
{
    byte b;
    uint8_t i2c_addr;
    char* op;

    if (do_verify && do_write) {
        op = "Write and Verify";
    } else
    if (do_verify) {
        op = "Verify";
    } else
    if (do_write) {
        op = "Write";
    } else
    if (do_read) {
        op = "Read";
    } else {
        op = "Dump internal data";
    }

    if (do_verify) {
        do_read = true;
    }

    Serial.print("Start ");
    Serial.print(op);
    Serial.print("...");
#ifdef EEPROM_I2C_CONFIG_ADDR
    i2c_write_byte(EEPROM_I2C_CONFIG_ADDR, 0, EEPROM_I2C_CONFIG_BYTE);
#endif
    if (cformat) {
        Serial.print("\n\nbyte eepromdat[] = {");
    }
    for (uint16_t index = 0; index < EEPROM_SIZE; index++) {
        if (index < sizeof(eepromdat)) {
            b = eepromdat[index];
        } else {
            b = 0xFF;
        }
        uint8_t d =  b;

        if (do_write) {
            i2c_eeprom_write_segment_byte(index, b, 0x100 <= index);
            delay(EEPROM_WRITE_DELAY);
	      }
        if (do_read) {
            i2c_eeprom_read_segment_byte(index, &d, 0x100 <= index);
	      }
        if (do_verify && b != d) {
            Serial.println();
            Serial.print(F("verification failed at 0x"));
	          Serial.print(index, HEX);
            Serial.print(", data=0x");
	          Serial.print(b, HEX);
            Serial.print(", eeprom=0x");
	          Serial.print(d, HEX);
            while (1);
        }

        if ((index % 16) == 0) {
            if (cformat) {
                if ((index % 128) != 0) {
                    Serial.print("\n    ");
                } else {
                    Serial.print("\n    // block ");
                    Serial.print(index / 128);
                    Serial.print("\n    ");
                }                    
            } else {
                Serial.println();
                if (index < 0x1000) Serial.print('0');
                if (index < 0x100) Serial.print('0');
                if (index < 0x10) Serial.print('0');
                Serial.print(index, HEX);
                Serial.print(": ");
            }
	      }
        Serial.print("0x");
        if (d < 0x10) Serial.print('0');
        Serial.print(d, HEX); //print content to serial port
        if (cformat || (index % 16) != 15)
            Serial.print(", ");
    }
    if (cformat) {
        Serial.println("\n};");
    }
    Serial.print("\n\r========\n\r");
    Serial.print(op);
    Serial.println(" finished!");
}

void setup() {
    Serial.begin(9600);
    while (!Serial);

    Serial.println();
    Serial.println(F("EEPROM WRITER"));
    Serial.print(F("EEPROM data size: "));
    Serial.println(sizeof(eepromdat));

    Wire.begin(); // initialise the connection

    do {
        Serial.println();
        Serial.println(F("   r: read from EEPROM"));
        Serial.println(F("  rd: read from EEPROM and display in C format"));
        Serial.println(F("   w: write to EEPROM"));
        Serial.println(F("   v: verify EEPROM"));
        Serial.println(F("  wv: write to EEPROM and verify"));
        Serial.println(F("   d: dump internal data"));
        Serial.println();
        Serial.println(F("input & return to start"));
        while (!Serial.available());
	String input;
        while (Serial.available()) {
            char c = Serial.read();
            if (isalnum(c))
                input += c;
        }
	Serial.print("input='");
	Serial.print(input);
	Serial.println("'");

        if (input == "r") {
            write_read_verify(false, true, false);
        } else
        if (input == "rd") {
            write_read_verify(false, true, false, true);
        } else
        if (input == "w") {
            write_read_verify(true, false, false);
        } else
        if (input == "v") {
            write_read_verify(false, false, true);
        } else
        if (input == "wv") {
            write_read_verify(true, false, false);
            Serial.println();
            write_read_verify(false, false, true);
        } else
        if (input == "d") {
            write_read_verify(false, false, false);
        }
    } while (true);
}

void loop() {
}
